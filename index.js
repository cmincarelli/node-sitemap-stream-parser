// Generated by CoffeeScript 1.12.7
(function() {
  var SitemapParser, agentOptions, async, headers, request, sax, urlParser, zlib,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  request = require('request');

  sax = require('sax');

  async = require('async');

  zlib = require('zlib');

  urlParser = require('url');

  headers = {
    'user-agent': process.env.USER_AGENT || 'node-sitemap-stream-parser'
  };

  agentOptions = {
    keepAlive: true
  };

  request = request.defaults({
    headers: headers,
    agentOptions: agentOptions,
    timeout: 60000
  });

  SitemapParser = (function() {
    function SitemapParser(url_cb1, sitemap_cb1) {
      this.url_cb = url_cb1;
      this.sitemap_cb = sitemap_cb1;
      this.parse = bind(this.parse, this);
      this.visited_sitemaps = {};
    }

    SitemapParser.prototype._download = function(url, parserStream) {
      var unzip;
      if (url.lastIndexOf('gz') === url.length - 2) {
        unzip = zlib.createUnzip();
        return request.get({
          url: url,
          encoding: null
        }).pipe(unzip).pipe(parserStream);
      } else {
        return request.get({
          url: url,
          gzip: true
        }).pipe(parserStream);
      }
    };

    SitemapParser.prototype.parse = function(url, done) {
      var inLoc, isSitemapIndex, isURLSet, parserStream;
      isURLSet = false;
      isSitemapIndex = false;
      inLoc = false;
      this.visited_sitemaps[url] = true;
      parserStream = sax.createStream(false, {
        trim: true,
        normalize: true,
        lowercase: true
      });
      parserStream.on('opentag', (function(_this) {
        return function(node) {
          inLoc = node.name === 'loc';
          if (node.name === 'urlset') {
            isURLSet = true;
          }
          if (node.name === 'sitemapindex') {
            return isSitemapIndex = true;
          }
        };
      })(this));
      parserStream.on('error', (function(_this) {
        return function(err) {
          return done(err);
        };
      })(this));
      parserStream.on('text', (function(_this) {
        return function(text) {
          text = urlParser.resolve(url, text);
          if (inLoc) {
            if (isURLSet) {
              return _this.url_cb(text);
            } else if (isSitemapIndex) {
              if (_this.visited_sitemaps[text] != null) {
                return console.error("Already parsed sitemap: " + text);
              } else {
                return _this.sitemap_cb(text);
              }
            }
          }
        };
      })(this));
      parserStream.on('end', (function(_this) {
        return function() {
          return done(null);
        };
      })(this));
      return this._download(url, parserStream);
    };

    return SitemapParser;

  })();

  exports.parseSitemap = function(url, url_cb, sitemap_cb, done) {
    var parser;
    parser = new SitemapParser(url_cb, sitemap_cb);
    return parser.parse(url, done);
  };

  exports.parseSitemaps = function(urls, url_cb, done) {
    var parser, queue;
    if (!(urls instanceof Array)) {
      urls = [urls];
    }
    parser = new SitemapParser(url_cb, function(sitemap) {
      return queue.push(sitemap);
    });
    queue = async.queue(parser.parse, 4);
    queue.drain = function() {
      return done(null, Object.keys(parser.visited_sitemaps));
    };
    return queue.push(urls);
  };

  exports.sitemapsInRobots = function(url, cb) {
    return request.get(url, function(err, res, body) {
      var matches;
      if (err) {
        return cb(err);
      }
      if (res.statusCode !== 200) {
        return cb("statusCode: " + res.statusCode);
      }
      matches = [];
      body.replace(/^Sitemap:\s?([^\s]+)$/igm, function(m, p1) {
        return matches.push(p1);
      });
      return cb(null, matches);
    });
  };

}).call(this);
